(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{563:function(t,n,e){"use strict";e.r(n);var s=e(12),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"ceshi"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ceshi"}},[t._v("#")]),t._v(" ceshi")]),t._v(" "),e("h2",{attrs:{id:"cc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cc"}},[t._v("#")]),t._v(" cc")]),t._v(" "),e("h3",{attrs:{id:"类的写法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类的写法"}},[t._v("#")]),t._v(" 类的写法")]),t._v(" "),e("p",[t._v("ES6新增class，让对象原型的写法更加清晰、更像面向对象编程语法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Point(x, y) {\n    this.x = x\n    this.y = y\n}\n\nPoint.prototype.toString = function () {\n    return this.x + this.y\n}\n\nclass Point {\n    constructor(x, y) {\n        this.x = x\n        this.y = y\n    }\n    \n    toString() {\n        return this.x + this.y\n    }\n}\n")])])]),e("p",[t._v("ES6的类完全可以看作是构造函数的另一种写法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("typeof Point // 'function'\nPoint === Point.prototype.constructor\n")])])]),e("ol",[e("li",[t._v("类的数据类型就是函数")]),t._v(" "),e("li",[t._v("类中存在和构造函数一样的"),e("code",[t._v("prototype")]),t._v("属性，"),e("code",[t._v("prototype")]),t._v("对象的"),e("code",[t._v("constructor")]),t._v("属性指向类的本身，这意味着类的所有方法都定义在"),e("code",[t._v("prototype")]),t._v("属性上面")]),t._v(" "),e("li",[t._v("但类的内部所有定义的方法都是不可枚举的，这点与ES5的行为不一致")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Point{\n    constructor() {}\n    toString() {}\n    toValue() {}\n}\n\n//等价于\nPoint.prototype = {\n    constructor() {},\n    toString() {},\n    toValue() {}\n}\n\n// 通过Object.assign 可以一次向类添加多个方法\nObject.assign(Point.prototype,{\n    toString() {},\n    toValue() {}\n})\n\n//获取原型上的属性\nObject.keys(Point.prototype) // []\nObject.getOwnPropertyNames(Point.prototype) // ['constructor', 'toString', 'toValue']\n")])])]),e("h3",{attrs:{id:"constructor方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#constructor方法"}},[t._v("#")]),t._v(" constructor方法")]),t._v(" "),e("p",[e("code",[t._v("constructor()")]),t._v("方法是类的默认方法且必须存在，通过"),e("code",[t._v("new")]),t._v("生成对象实例时自动调用，如果没有显示定义，一个空的"),e("code",[t._v("constructor")]),t._v("方法会被默认添加。"),e("br"),t._v(" "),e("code",[t._v("constructor()")]),t._v("方法默认返回实例对象(this)，但可以指定返回一个全新的对象。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Foo {\n    constructor() {\n        return Object.create(null)\n    }\n}\nnew Foo() instanceof Foo  // false\n")])])]),e("h3",{attrs:{id:"类的实例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类的实例"}},[t._v("#")]),t._v(" 类的实例")]),t._v(" "),e("p",[t._v("与ES5一样，实例的属性除非定义在this对象上，否则都是定义在原型上。"),e("br"),t._v("\n类的所有实例都共享一个原型对象，你可以通过某个实例的"),e("code",[t._v("__proto__")]),t._v("属性访问类的原型，为类添加共享的方法。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const p1 = new Point(2, 3)\nconst p2 = new Point(1, 2)\n\npoint.hasOwnProperty('x') //true\npoint.hasOwnProperty('y') //true\npoint.hasOwnProperty('toString') //false\npoint.__proto__.hasOwnProperty('toString') // true\n\np1.__proto__  === p2.__proto__\np1.__protp__.printName = function() {return 'ops' }\np1.printName() //'ops'\np2.printName() //'ops'\n\nconst p3 = new Point(2，3)\np3.printName() //'ops'\n\n也可以通过Object.getprototypeOf()获取实例对象的原型\nObject.getprototypeOf(p1) === p1.__proto__ = Point.prototype\n")])])]),e("h3",{attrs:{id:"get-set-关键字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get-set-关键字"}},[t._v("#")]),t._v(" get / set 关键字")]),t._v(" "),e("p",[t._v("类的内部可以使用get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截属性存取行为。"),e("br"),t._v("\n存/取值函数都是设置在属性的Descriptor对象上的。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class CustomHTMLElement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get html() {\n    return this.element.innerHTML;\n  }\n\n  set html(value) {\n    this.element.innerHTML = value;\n  }\n}\n")])])]),e("h3",{attrs:{id:"静态方法-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态方法-属性"}},[t._v("#")]),t._v(" 静态方法/属性")]),t._v(" "),e("p",[t._v("在类中定义的方法前加上"),e("code",[t._v("static")]),t._v("关键字表示静态方法，该方法不会被实例所继承，而是直接通过类来调用。")]),t._v(" "),e("ol",[e("li",[t._v("如果静态方法包含"),e("code",[t._v("this")]),t._v("关键字，this指向这个类而不是实例。")]),t._v(" "),e("li",[t._v("静态方法可以和非静态方法重名。")]),t._v(" "),e("li",[t._v("父类的静态方法可以被子类继承并且可以从"),e("code",[t._v("super")]),t._v("对象上调用。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Foo {\n    static bar() {\n        this.baz()\n    }\n    static baz() {\n        console.log('hello')\n    }\n    baz() {\n        console.log('world')\n    }\n}\n\nFoo.bar()  //hello\nconst f = new Foo()\nf.bar() // f.bar id not a function \n\n")])])]),e("p",[t._v("ES6明确规定，Class内部只有静态属性没有静态方法。但目前有提案提供了"),e("code",[t._v("static")]),t._v("去标识静态属性。")]),t._v(" "),e("h3",{attrs:{id:"私有方法-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#私有方法-属性"}},[t._v("#")]),t._v(" 私有方法/属性")]),t._v(" "),e("p",[t._v("私有方法和私有属性是只能在类的内部访问的方法和属性，ES6不提供支持，可以通过以下两种方法变通实现。")]),t._v(" "),e("ol",[e("li",[t._v("将私有方法移出类，因为类内部的所有方法都是对外可见的。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Widget {\n    foo(baz) {\n        bar.call(this, baz)\n    }\n}\n\nfunction bar(baz) {\n    return this.snaf = baz\n}\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const bar = Symbol('bar')\nconst snaf = Symbol('snaf')\nclass myClass {\n    foo(baz) {\n        this[bar](baz)\n    }\n    [bar](baz) {\n        return this[snaf] = baz\n    }\n}\n")])])]),e("p",[t._v("目前，有一个提案为"),e("code",[t._v("class")]),t._v("加了私有属性。方法是在属性名之前，使用"),e("code",[t._v("#")]),t._v("表示。")]),t._v(" "),e("h3",{attrs:{id:"new-target-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-target-属性"}},[t._v("#")]),t._v(" new.target 属性")]),t._v(" "),e("p",[t._v("ES6为"),e("code",[t._v("new")]),t._v("命令引入了一个"),e("code",[t._v("new.target")]),t._v("属性，该属性一般用在构造函数之中，返回"),e("code",[t._v("new")]),t._v("命令作用于的那个构造函数。")]),t._v(" "),e("ol",[e("li",[t._v("如果构造函数不是通过"),e("code",[t._v("new")]),t._v("命令调用的，"),e("code",[t._v("new.target")]),t._v("会返回"),e("code",[t._v("undefined")]),t._v("。")]),t._v(" "),e("li",[t._v("Class内部调用"),e("code",[t._v("new.target")]),t._v("，返回当前Class。")]),t._v(" "),e("li",[t._v("当子类继承父类时，"),e("code",[t._v("new.target")]),t._v("返回子类，利用这一特性可以写出不能独立使用、必须继承使用的类。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用 new 命令生成实例');\n  }\n}\n\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用 new 命令生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Shape {\n  constructor() {\n    if (new.target === Shape) {\n      throw new Error('本类不能实例化');\n    }\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(length, width) {\n    super();\n    // ...\n  }\n}\n\nvar x = new Shape();  // 报错\nvar y = new Rectangle(3, 4);  // 正确\n")])])]),e("h3",{attrs:{id:"继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),e("p",[t._v("Class可以通过"),e("code",[t._v("extends")]),t._v("关键字实现继承。"),e("br"),t._v("\n子类必须在"),e("code",[t._v("constructor")]),t._v("方法中调用"),e("code",[t._v("super")]),t._v("方法。因为子类的"),e("code",[t._v("this")]),t._v("对象是先通过父类的构造函数完成创建，加工得到父类的属性和方法，再加上自身实例的属性和方法所构成。而ES5的继承，实质上是先创造子类的实例对象"),e("code",[t._v("this")]),t._v("，通过"),e("code",[t._v("parent.apply(this)")]),t._v("继承父类的方法，所以"),e("code",[t._v("this")]),t._v("关键字需在"),e("code",[t._v("super")]),t._v("调用后使用。"),e("br"),t._v("\n子类如果没有定义"),e("code",[t._v("constructor")]),t._v("方法也会默认添加带"),e("code",[t._v("super")]),t._v("的空函数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n")])])]),e("h3",{attrs:{id:"super关键字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super关键字"}},[t._v("#")]),t._v(" super关键字")]),t._v(" "),e("p",[e("code",[t._v("super")]),t._v("关键字的使用在于理解两种不同的使用场景以及内部的"),e("code",[t._v("this")]),t._v("指向")]),t._v(" "),e("ol",[e("li",[e("code",[t._v("super")]),t._v("当作函数调用，代表父类的构造函数，但是"),e("code",[t._v("super()")]),t._v("返回的是子类的实例。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class A {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\nnew A() // A\nnew B() // B\n")])])]),e("p",[e("code",[t._v("super()")]),t._v("在这里相当于"),e("code",[t._v("A.prototype.constructor.call(this)")]),t._v("，"),e("code",[t._v("super()")]),t._v("内部的"),e("code",[t._v("this")]),t._v("指向的是"),e("code",[t._v("B")]),t._v("。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("code",[t._v("super")]),t._v("当作对象时，在普通方法中指向父类的原型对象，在静态方法中，指向父类。")])]),t._v(" "),e("p",[t._v("ES6规定，在子类普通方法中通过"),e("code",[t._v("super")]),t._v("调用父类的方法时，方法内部的"),e("code",[t._v("this")]),t._v("指向当前的子类实例。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n    super.x = 3\n    console.log(super.x) // undefined\n    console.log(this.x) // 3\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n")])])]),e("p",[e("code",[t._v("super.print()")]),t._v("虽然调用的是"),e("code",[t._v("A.prototype.print()")]),t._v("，但是内部的"),e("code",[t._v("this")]),t._v("指向的是子类"),e("code",[t._v("B")]),t._v("的实例，所以输出的是"),e("code",[t._v("3")]),t._v("，所以如果通过"),e("code",[t._v("super")]),t._v("对某个属性赋值，属性相当于加到子类实例上。而当读取"),e("code",[t._v("super.x")]),t._v("时，访问的是"),e("code",[t._v("A.prototype.x")]),t._v("，返回"),e("code",[t._v("undefined")]),t._v("。")]),t._v(" "),e("p",[t._v("另外，联想到"),e("code",[t._v("super()")]),t._v("在静态方法中的使用时，方法内部的"),e("code",[t._v("this")]),t._v("指向当前的子类，而不是子类的实例。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class A {\n  constructor() {\n    this.x = 1;\n  }\n  static print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  static m() {\n    super.print();\n  }\n}\n\nB.x = 3;\nB.m() // 3\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);